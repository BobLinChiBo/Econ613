log_likelihood(test_beta, X, y)
## 2
datind2007_employ <-  datind2007_clear %>% mutate(employed =  empstat == "Employed")
age <- datind2007_employ$age
constant <- rep(1, length(age))
X <- matrix(c(constant, age), nrow = length(age), ncol = 2)
y <- datind2007_employ$employed
log_likelihood <- function(beta, matrix_X, y){
y_latent <- matrix_X %*% beta
prob_y_1 <- pnorm(y_latent)
prob_y_1[prob_y_1 > 0.999999] = 0.999999
prob_y_1[prob_y_1 < 0.000001] = 0.000001
log_likelihood <- sum(y * log(prob_y_1) + (1-y) * log(1-prob_y_1))
return(log_likelihood)
}
reg1 = glm(employed ~ age, family = binomial(link = "probit"), datind2007_employ)
summary(reg1)
set.seed(123)
times <- 100
empty_list <- vector(mode = "list", length = times)
start_points <- lapply(empty_list, function(x) runif(n = 2, min = -3, max = 3))
results <- lapply(X = start_points, FUN = optim,
fn = log_likelihood,
method="BFGS",
control=list(trace=6, maxit=1000, fnscale = -1),
matrix_X = X, y = y)
View(results)
logLik_results <- lapply(results, "[[", 2)
View(logLik_results)
max(unlist(logLik_results))
logLik(reg1)
which(unlist(logLik_results) == max(unlist(logLik_results)))
which(unlist(logLik_results) == max_logLik)
max_logLik <- max(unlist(logLik_results))
which(unlist(logLik_results) == max_logLik)
View(start_points)
start_points[[which(unlist(logLik_results) == max_logLik)]]
optim(true_start_point,
log_likelihood,
method="BFGS",
control=list(trace=6, maxit=1000, fnscale = -1),
matrix_X = X, y = y,
hessian = TRUE)
true_start_point <- start_points[[which(unlist(logLik_results) == max_logLik)]]
optim(true_start_point,
log_likelihood,
method="BFGS",
control=list(trace=6, maxit=1000, fnscale = -1),
matrix_X = X, y = y,
hessian = TRUE)
best_start_point <- start_points[[which(unlist(logLik_results) == max_logLik)]]
best_result <- optim(best_start_point,
log_likelihood,
method="BFGS",
control=list(trace=6, maxit=1000, fnscale = -1),
matrix_X = X, y = y,
hessian = TRUE)
fisher_info_matrix = solve(-best_result$hessian)
prop_sigma  = sqrt(diag(fisher_info_matrix))
prop_sigma
summary(reg1)
fisher_info_matrix = solve(-best_result$hessian)
std_error  = sqrt(diag(fisher_info_matrix))
std_error
estimates = cbind(summary(reg_glm)$coefficients[, 1], summary(reg_glm)$coefficients[, 2], best_result$par, std_error)
colnames(est) = c("R: GLM : est","R: GLM :se","R: own : est","R: own :se")
colnames(estimates) = c("R: GLM : est","R: GLM :se","R: own : est","R: own :se")
estimates = cbind(summary(reg_glm)$coefficients[, 1], summary(reg_glm)$coefficients[, 2], best_result$par, std_error)
reg_glm = glm(employed ~ age, family = binomial(link = "probit"), datind2007_employ)
summary(reg_glm)
test_beta = reg_glm$coefficients
log_likelihood(test_beta, X, y)
logLik(reg_glm)
estimates = cbind(summary(reg_glm)$coefficients[, 1], summary(reg_glm)$coefficients[, 2], best_result$par, std_error)
colnames(estimates) = c("R: GLM : est","R: GLM :se","R: own : est","R: own :se")
estimates
rm(list = ls())
library(tidyverse)
library(ggplot2)
library(scales)
setwd("C:/Users/boblin/Documents/GitHub/Econ613/Assignments/A2")
read_datind <- function(filename){
path <- paste("./Data/", filename, sep = "")
return(
suppressMessages( # to suppress the message that arises from reading a column without name
read_csv(path,
col_types = list(idind = "c", idmen = "c", profession = "c") # read "idind","idmen", and "profession" as character
)) %>%
mutate(across(c(idind, idmen, empstat, profession, gender), as_factor)) %>% # to reduce the size of data set
select(!starts_with("...")) # remove first column
)
}
### Exercise 1
datind2009 <- read_datind("datind2009.csv")
datind2009_clear <- datind2009 %>% filter(!is.na(wage) & wage != 0) %>% select(wage, age)
## 1 & 2
reg_wage_age <- function(data){
age <- data$age
constant <- rep(1, length(age))
X <- matrix(c(constant, age), nrow = length(age), ncol = 2)
Y <- data$wage
suppressWarnings( # to suppress the message that arises from reading a column without variation
correlation_result <- cor(X, Y, use = "complete.obs")
)
colnames(correlation_result) = "wage_correlation"
rownames(correlation_result) = c("intercept", "age")
beta_hat <- solve(t(X) %*% X) %*% t(X) %*% Y
Y_hat <- X %*% beta_hat
error <- Y - Y_hat
S_square <- (t(error) %*% error / (length(Y) - 2))[1,1]
var_beta <- S_square * solve(t(X) %*% X)
Std_Error <- sqrt(diag(var_beta))
regression_result <- matrix(c(beta_hat, t(Std_Error)), nrow = 2, ncol = 2)
colnames(regression_result) = c("Coefficients", "Std_Error")
rownames(regression_result) = c("intercept", "age")
return(list(correlation_result, regression_result))
}
fun_reg <- reg_wage_age(datind2009_clear)
fun_reg
lm_reg <- lm(wage ~ age, datind2009_clear) # check
summary(lm_reg) # correct
summary(lm_reg)$coefficients # correct
summary(lm_reg)$coefficients["Estimates", drop = FALSE] # correct
summary(lm_reg)$coefficients["Estimates", drop = FALSE] # correct
summary(lm_reg)$coefficients
summary(lm_reg)$coefficients["Estimate", drop = FALSE] # correct
summary(lm_reg)$coefficients[,"Estimate", drop = FALSE] # correct
fun_reg
## 1
fun_reg[[1]]
## 2
fun_reg[[2]]
lm_reg <- lm(wage ~ age, datind2009_clear) # check
summary(lm_reg)$coefficients[,"Estimate", drop = FALSE] # correct
summary(lm_reg)$coefficients[,c("Estimate","Std_Error"), drop = FALSE] # correct
summary(lm_reg)$coefficients[, , drop = FALSE] # correct
summary(lm_reg)$coefficients[, c("Estimate","Std. Error"), drop = FALSE] # correct
## 2
fun_reg[[2]]
lm_reg <- lm(wage ~ age, datind2009_clear) # check
summary(lm_reg)$coefficients[, c("Estimate","Std. Error"), drop = FALSE] # correct
## 3
bootstrap <- function(data, times){
set.seed(123)
samples <- lapply(rep(list(data), times), FUN = slice_sample, n = length(data$wage), replace = TRUE)
results <- lapply(samples, reg_wage_age)
regression_results <- lapply(results, "[[", 2)
constant_coef <- lapply(regression_results, "[", 1, 1)
age_coef <- lapply(regression_results, "[", 2, 1)
sd_constant_coef <- sd(unlist(constant_coef))
sd_age_coef <- sd(unlist(age_coef))
bootstrap_result <- matrix(c(sd_constant_coef, sd_age_coef), nrow = 2, ncol = 1)
colnames(bootstrap_result) ="Std_Error"
rownames(bootstrap_result) = c("intercept", "age")
return(bootstrap_result)
}
fun_reg[[2]][, "Std_Error", drop = FALSE]
bootstrap(datind2009_clear, 49)
bootstrap(datind2009_clear, 499)
### Exercise 2
years <- 2005:2018
filenames = paste(rep("datind", length(years)), years, ".csv", sep = "")
data_ind <- map_dfr(filenames, read_datind)
data_ind_clear <-
data_ind %>%
filter(age >= 18) %>%
filter(!is.na(wage) & wage != 0) %>%
mutate(year = as.factor(year))
## 1
data_ind_age_group <-
data_ind_clear %>%
mutate(age_group = cut(age, c(18, 25, 30, 35, 40, 45, 50, 55, 60, max(age)), include.lowest = TRUE))
## 2
# Plotting only those wage lower than 100,000 to make the graph readable
# As age rises (until 60), the wage seems also rises.
data_ind_age_group %>%
ggplot(aes(x = age_group, y = wage)) +
geom_boxplot() +
scale_y_continuous(labels = label_comma(), limits = c(NA, 100000))
## 3
# After adding the year fixed effect, the coefficient of age increases and the coefficient of intercept decreases.
lm(wage ~ age + year, data_ind_clear)
fun_reg
fun_reg[[2]]
## 3
# After adding the year fixed effect, the coefficient of age increases and the coefficient of intercept decreases.
lm(wage ~ age + year, data_ind_clear)$$coefficients
## 3
# After adding the year fixed effect, the coefficient of age increases and the coefficient of intercept decreases.
lm(wage ~ age + year, data_ind_clear)$coefficients
View(lm_reg)
View(lm_reg)
summary(lm_reg)$coefficients
summary(lm_reg)$coefficients[, c("Estimate","Std. Error"), drop = FALSE] # correct
## 3
# After adding the year fixed effect, the coefficient of age increases and the coefficient of intercept decreases.
lm(wage ~ age + year, data_ind_clear)$coefficients
## 3
# After adding the year fixed effect, the coefficient of age increases and the coefficient of intercept decreases.
lm_year_reg <- lm(wage ~ age + year, data_ind_clear)
summary(lm_year_reg)$coefficients
summary(lm_year_reg)$coefficients[c("(Intercept)", "age"), c("Estimate", "Std. Error")]
fun_reg[[2]]
### Exercise 3
datind2007 <- read_datind("datind2007.csv")
## 1
datind2007_clear <-
datind2007 %>%
filter(empstat != "Inactive" & empstat != "Retired")
## 2
datind2007_employ <-  datind2007_clear %>% mutate(employed =  empstat == "Employed")
age <- datind2007_employ$age
age <- datind2007_employ$age
constant <- rep(1, length(age))
X <- matrix(c(constant, age), nrow = length(age), ncol = 2)
y <- datind2007_employ$employed
log_likelihood <- function(beta, matrix_X, y){
y_latent <- matrix_X %*% beta
prob_y_1 <- pnorm(y_latent)
prob_y_1[prob_y_1 > 0.999999] = 0.999999
prob_y_1[prob_y_1 < 0.000001] = 0.000001
log_likelihood <- sum(y * log(prob_y_1) + (1-y) * log(1-prob_y_1))
return(log_likelihood)
}
set.seed(123)
times <- 100
empty_list <- vector(mode = "list", length = times)
start_points <- lapply(empty_list, function(x) runif(n = 2, min = -3, max = 3))
results <- lapply(X = start_points, FUN = optim,
fn = log_likelihood,
method="BFGS",
control=list(trace=6, maxit=1000, fnscale = -1),
matrix_X = X, y = y)
logLik_results <- lapply(results, "[[", 2)
max_logLik <- max(unlist(logLik_results))
best_start_point <- start_points[[which(unlist(logLik_results) == max_logLik)]]
best_result <- optim(best_start_point,
log_likelihood,
method="BFGS",
control=list(trace=6, maxit=1000, fnscale = -1),
matrix_X = X, y = y,
hessian = TRUE)
fisher_info_matrix = solve(-best_result$hessian)
std_error  = sqrt(diag(fisher_info_matrix))
std_error
reg_glm = glm(employed ~ age, family = binomial(link = "probit"), datind2007_employ)
summary(reg_glm)
test_beta = reg_glm$coefficients
log_likelihood(test_beta, X, y)
logLik(reg_glm)
estimates = cbind(summary(reg_glm)$coefficients[, 1], summary(reg_glm)$coefficients[, 2], best_result$par, std_error)
colnames(estimates) = c("R: GLM : est","R: GLM :se","R: own : est","R: own :se")
estimates
## 4
age <- datind2007_employ$age
wage <- datind2007_employ$wage
constant <- rep(1, length(age))
X <- matrix(c(constant, age, wage), nrow = length(age), ncol = 2)
y <- datind2007_employ$employed
## 3
optim_result <- function(n_start_points, min, max, matrix_X, y, times){
set.seed(123)
empty_list <- vector(mode = "list", length = times)
start_points <- lapply(empty_list, function(x) runif(n = 2, min = -3, max = 3))
results <- lapply(X = start_points, FUN = optim,
fn = log_likelihood,
method="BFGS",
control=list(trace=6, maxit=1000, fnscale = -1),
matrix_X = matrix_X, y = y)
logLik_results <- lapply(results, "[[", 2)
max_logLik <- max(unlist(logLik_results))
best_start_point <- start_points[[which(unlist(logLik_results) == max_logLik)]]
best_result <- optim(best_start_point,
log_likelihood,
method="BFGS",
control=list(trace=6, maxit=1000, fnscale = -1),
matrix_X = X, y = y,
hessian = TRUE)
fisher_info_matrix = solve(-best_result$hessian)
std_error  = sqrt(diag(fisher_info_matrix))
std_error
reg_glm = glm(employed ~ age, family = binomial(link = "probit"), datind2007_employ)
summary(reg_glm)
test_beta = reg_glm$coefficients
log_likelihood(test_beta, X, y)
logLik(reg_glm)
estimates = cbind(summary(reg_glm)$coefficients[, 1], summary(reg_glm)$coefficients[, 2], best_result$par, std_error)
colnames(estimates) = c("R: GLM : est","R: GLM :se","R: own : est","R: own :se")
return(estimates)
}
optim_result(2, -3, 3, X, y, 100)
## 4
age <- datind2007_employ$age
wage <- datind2007_employ$wage
constant <- rep(1, length(age))
X <- matrix(c(constant, age, wage), nrow = length(age), ncol = 2)
## 4
age <- datind2007_employ$age
wage <- datind2007_employ$wage
constant <- rep(1, length(age))
X <- matrix(c(constant, age, wage), nrow = length(age), ncol = 3)
View(X)
y <- datind2007_employ$employed
optim_result(3, -3, 3, X, y, 100)
## 3
optim_result <- function(n_start_points, min, max, matrix_X, y, times){
set.seed(123)
empty_list <- vector(mode = "list", length = times)
start_points <- lapply(empty_list, function(x) runif(n = n_start_points, min = min, max = max))
results <- lapply(X = start_points, FUN = optim,
fn = log_likelihood,
method="BFGS",
control=list(trace=6, maxit=1000, fnscale = -1),
matrix_X = matrix_X, y = y)
logLik_results <- lapply(results, "[[", 2)
max_logLik <- max(unlist(logLik_results))
best_start_point <- start_points[[which(unlist(logLik_results) == max_logLik)]]
best_result <- optim(best_start_point,
log_likelihood,
method="BFGS",
control=list(trace=6, maxit=1000, fnscale = -1),
matrix_X = X, y = y,
hessian = TRUE)
fisher_info_matrix = solve(-best_result$hessian)
std_error  = sqrt(diag(fisher_info_matrix))
std_error
reg_glm = glm(employed ~ age, family = binomial(link = "probit"), datind2007_employ)
summary(reg_glm)
test_beta = reg_glm$coefficients
log_likelihood(test_beta, X, y)
logLik(reg_glm)
estimates = cbind(summary(reg_glm)$coefficients[, 1], summary(reg_glm)$coefficients[, 2], best_result$par, std_error)
colnames(estimates) = c("R: GLM : est","R: GLM :se","R: own : est","R: own :se")
return(estimates)
}
optim_result(2, -3, 3, X, y, 100)
## 2
datind2007_employ <-  datind2007_clear %>% mutate(employed =  empstat == "Employed")
age <- datind2007_employ$age
constant <- rep(1, length(age))
X <- matrix(c(constant, age), nrow = length(age), ncol = 2)
y <- datind2007_employ$employed
log_likelihood <- function(beta, matrix_X, y){
y_latent <- matrix_X %*% beta
prob_y_1 <- pnorm(y_latent)
prob_y_1[prob_y_1 > 0.999999] = 0.999999
prob_y_1[prob_y_1 < 0.000001] = 0.000001
log_likelihood <- sum(y * log(prob_y_1) + (1-y) * log(1-prob_y_1))
return(log_likelihood)
}
## 3
optim_result <- function(n_start_points, min, max, matrix_X, y, times){
set.seed(123)
empty_list <- vector(mode = "list", length = times)
start_points <- lapply(empty_list, function(x) runif(n = n_start_points, min = min, max = max))
results <- lapply(X = start_points, FUN = optim,
fn = log_likelihood,
method="BFGS",
control=list(trace=6, maxit=1000, fnscale = -1),
matrix_X = matrix_X, y = y)
logLik_results <- lapply(results, "[[", 2)
max_logLik <- max(unlist(logLik_results))
best_start_point <- start_points[[which(unlist(logLik_results) == max_logLik)]]
best_result <- optim(best_start_point,
log_likelihood,
method="BFGS",
control=list(trace=6, maxit=1000, fnscale = -1),
matrix_X = X, y = y,
hessian = TRUE)
fisher_info_matrix = solve(-best_result$hessian)
std_error  = sqrt(diag(fisher_info_matrix))
std_error
reg_glm = glm(employed ~ age, family = binomial(link = "probit"), datind2007_employ)
summary(reg_glm)
test_beta = reg_glm$coefficients
log_likelihood(test_beta, X, y)
logLik(reg_glm)
estimates = cbind(summary(reg_glm)$coefficients[, 1], summary(reg_glm)$coefficients[, 2], best_result$par, std_error)
colnames(estimates) = c("R: GLM : est","R: GLM :se","R: own : est","R: own :se")
return(estimates)
}
optim_result(2, -3, 3, X, y, 100)
## 4
age <- datind2007_employ$age
wage <- datind2007_employ$wage
constant <- rep(1, length(age))
X <- matrix(c(constant, age, wage), nrow = length(age), ncol = 3)
y <- datind2007_employ$employed
optim_result(3, -3, 3, X, y, 100)
## 4
datind2007_employ_wage %>% datind2007_employ %>% mutate(positive_wage = wage > 0)
## 4
datind2007_employ_wage <- datind2007_employ %>% mutate(positive_wage = wage > 0)
?table
## 4
datind2007_employ_wage <- datind2007_employ %>% mutate(positive_wage = wage > 0)
datind2007_employ_wage %>%
count(employed, positive_wage) %>%
pivot_wider(names_from = employed, values_from = n)
View(datind2007_employ_wage)
View(datind2007)
rm(list = ls())
library(tidyverse)
library(ggplot2)
library(scales)
setwd("C:/Users/boblin/Documents/GitHub/Econ613/Assignments/A2")
read_datind <- function(filename){
path <- paste("./Data/", filename, sep = "")
return(
suppressMessages( # to suppress the message that arises from reading a column without name
read_csv(path,
col_types = list(idind = "c", idmen = "c", profession = "c") # read "idind","idmen", and "profession" as character
)) %>%
mutate(across(c(idind, idmen, empstat, profession, gender), as_factor)) %>% # to reduce the size of data set
select(!starts_with("...")) # remove first column
)
}
### Exercise 1
datind2009 <- read_datind("datind2009.csv")
datind2009_clear <- datind2009 %>% filter(!is.na(wage) & wage != 0) %>% select(wage, age)
reg_self <- function(matrix_X, y){
beta_hat <- solve(t(X) %*% X) %*% t(X) %*% Y
Y_hat <- X %*% beta_hat
error <- Y - Y_hat
S_square <- (t(error) %*% error / (length(Y) - 2))[1,1]
var_beta <- S_square * solve(t(X) %*% X)
Std_Error <- sqrt(diag(var_beta))
regression_result <- matrix(c(beta_hat, t(Std_Error)), nrow = 2, ncol = 2)
colnames(regression_result) = c("Coefficients", "Std_Error")
rownames(regression_result) = c("intercept", "age")
return( regression_result)
}
age <- data$age
age <- datind2009_clear$age
constant <- rep(1, length(age))
X <- matrix(c(constant, age), nrow = length(age), ncol = 2)
y <- datind2009_clear$wage
correlation_result <- cor(X, y, use = "complete.obs")
colnames(correlation_result) = "wage_correlation"
rownames(correlation_result) = c("intercept", "age")
correlation_result
fun_reg <- reg_self(X, y)
reg_self <- function(matrix_X, y){
beta_hat <- solve(t(X) %*% X) %*% t(X) %*% Y
y_hat <- X %*% beta_hat
error <- y - y_hat
S_square <- (t(error) %*% error / (length(y) - 2))[1,1]
var_beta <- S_square * solve(t(X) %*% X)
Std_Error <- sqrt(diag(var_beta))
regression_result <- matrix(c(beta_hat, t(Std_Error)), nrow = 2, ncol = 2)
colnames(regression_result) = c("Coefficients", "Std_Error")
rownames(regression_result) = c("intercept", "age")
return( regression_result)
}
fun_reg <- reg_self(X, y)
reg_self <- function(matrix_X, y){
beta_hat <- solve(t(X) %*% X) %*% t(X) %*% y
y_hat <- X %*% beta_hat
error <- y - y_hat
S_square <- (t(error) %*% error / (length(y) - 2))[1,1]
var_beta <- S_square * solve(t(X) %*% X)
Std_Error <- sqrt(diag(var_beta))
regression_result <- matrix(c(beta_hat, t(Std_Error)), nrow = 2, ncol = 2)
colnames(regression_result) = c("Coefficients", "Std_Error")
rownames(regression_result) = c("intercept", "age")
return( regression_result)
}
fun_reg <- reg_self(X, y)
## 2
fun_reg <- reg_self(X, y)
X <- matrix(c(constant, age), nrow = length(age), ncol = 2)
y <- datind2009_clear$wage
## 1
correlation_result <- cor(X, y, use = "complete.obs")
colnames(correlation_result) = "wage_correlation"
rownames(correlation_result) = c("intercept", "age")
correlation_result
## 2
fun_reg <- reg_self(X, y)
fun_reg
lm_reg <- lm(wage ~ age, datind2009_clear) # check
summary(lm_reg)$coefficients[, c("Estimate","Std. Error"), drop = FALSE] # correct
## 3
bootstrap <- function(data, times){
set.seed(123)
samples <- lapply(rep(list(data), times), FUN = slice_sample, n = length(data$wage), replace = TRUE)
regression_results <- lapply(samples, reg_wage_age)
constant_coef <- lapply(regression_results, "[", 1, 1)
age_coef <- lapply(regression_results, "[", 2, 1)
sd_constant_coef <- sd(unlist(constant_coef))
sd_age_coef <- sd(unlist(age_coef))
bootstrap_result <- matrix(c(sd_constant_coef, sd_age_coef), nrow = 2, ncol = 1)
colnames(bootstrap_result) ="Std_Error"
rownames(bootstrap_result) = c("intercept", "age")
return(bootstrap_result)
}
# The estimated standard error of using the two strategies are different though the difference is not large.
# The standard formulas of the OLS assume the variance of error term is homoskedastic and not autocorrelated.
# However, bootstrap directly uses the information that the data brings.
fun_reg[, "Std_Error", drop = FALSE]
bootstrap(datind2009_clear, 49)
reg_wage_age <- function(data){
age <- data$age
constant <- rep(1, length(age))
X <- matrix(c(constant, age), nrow = length(age), ncol = 2)
y <- data$wage
reg_self(X, y)
}
lm
?model.matrix
?match.call
?call
